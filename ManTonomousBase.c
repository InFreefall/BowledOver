#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S4,     compass,        sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rSholder,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorLift,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     rbCollector,   tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     lSholder,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     lDrive,        tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     rDrive,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    rFinger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lFinger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    rWrist,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_4,    lWrist,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_5,    rElbow,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_6,    lElbow,               tServoContinuousRotation)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "rdpartyrobotcdr-v2.4/drivers/HTMC-driver.h"

#define TERRAIN_MODIFIER            1.0
#define AUTO_SPEED                  80

#ifdef TURN_RIGHT
#define DESCEND_RAMP_TIME           2265
#define TURN_ANGLE                  73
#define DRIVE_TOWARDS_BALL_TIME     1600
#define HEAD_FOR_CORNER_DELAY       4600
#define TURN_TO_CORNER_ANGLE        20
#endif
#ifdef TURN_LEFT

#define DESCEND_RAMP_TIME           2365
#define TURN_ANGLE                  65
#define DRIVE_TOWARDS_BALL_TIME     1600
#define HEAD_FOR_CORNER_DELAY       4600
#define TURN_TO_CORNER_ANGLE        37

#endif

void setLeftDrive(int power)
{
  motor[lDrive] = power;
}

void setRightDrive(int power)
{
  motor[rDrive] = power;
}

void stopDrive()
{
  motor[rDrive] = 0;
  motor[lDrive] = 0;
}

void descendRamp();
void turnRight();
void turnLeft();
void driveTowardsBall();
void rotateTowardsCorner();
void headForCorner();
void rotateTo(int dTheta, bool right);

task main()
{
  waitForStart();
  descendRamp();
#ifdef TURN_RIGHT
  turnRight();
#endif
#ifdef TURN_LEFT
  turnLeft();
#endif
  driveTowardsBall();
  rotateTowardsCorner();
  headForCorner();
}

void descendRamp()
{
  setRightDrive(45);
  setLeftDrive(45);
  wait1Msec(DESCEND_RAMP_TIME * TERRAIN_MODIFIER);
  stopDrive();
}

void turnRight()
{
  rotateTo(TURN_ANGLE,false);
}

void turnLeft()
{
  rotateTo(TURN_ANGLE,true);
}

void driveTowardsBall()
{
  setLeftDrive(-AUTO_SPEED);
  setRightDrive(-AUTO_SPEED);
  wait1Msec(DRIVE_TOWARDS_BALL_TIME * TERRAIN_MODIFIER);
  stopDrive();
}

void rotateTowardsCorner()
{
  bool right = false;
#ifdef TURN_RIGHT
  right = true;
#endif
  rotateTo(TURN_TO_CORNER_ANGLE,right);
}

void headForCorner()
{
  setRightDrive(-100);
  setLeftDrive(-100);
  wait1Msec(HEAD_FOR_CORNER_DELAY*TERRAIN_MODIFIER);
  stopDrive();
}

void rotateTo(int dTheta, bool right)
{
  int currentHeading = HTMCreadHeading(compass);
  int originalHeading = HTMCreadHeading(compass);
  int nTurns = 0;
  int nTurnsNeeded = 0;
  int target;
  if (right)
  {
    target = originalHeading + dTheta;
    if (target > 359)
    {
     target -= 360;
     nTurnsNeeded = 1;
    }

    setRightDrive(-AUTO_SPEED);
    setLeftDrive(AUTO_SPEED);

    int lastHeading = 0;
    while (!((currentHeading > target) && (nTurns == nTurnsNeeded)))
    {
     if (abs(HTMCreadHeading(compass) - currentHeading) > 20)
       nTurns++;
     currentHeading = HTMCreadHeading(compass);
     if (lastHeading != currentHeading)
     writeDebugStreamLine("%d",currentHeading);
     lastHeading=currentHeading;
    }
  }
  else
  {
    target = originalHeading - dTheta;
    if (target < 0)
    {
      target += 360;
      nTurnsNeeded = 1;
    }

    setRightDrive(AUTO_SPEED);
    setLeftDrive(-AUTO_SPEED);

    int lastHeading = 0;
    while (!((currentHeading < target) && (nTurns == nTurnsNeeded)))
    {
     if (abs(HTMCreadHeading(compass) - currentHeading) > 20)
       nTurns++;
     currentHeading = HTMCreadHeading(compass);
     if (lastHeading != currentHeading)
     writeDebugStreamLine("%d",currentHeading);
     lastHeading=currentHeading;
    }
  }
  stopDrive();
}
