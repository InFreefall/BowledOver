#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S2,     ultrasonic,     sensorSONAR)
#pragma config(Sensor, S3,     compass,        sensorI2CCustom)
#pragma config(Motor,  mtr_S4_C1_1,     motorNorth,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     motorEast,     tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorWest,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_2,     motorSouth,    tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     shoulder,      tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     elbow,         tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rdpartyrobotcdr-v2.4/drivers/HTMC-driver.h"
#include "JoystickDriver.c"

// These are radians
const int FORWARDS = PI;
const int RIGHT = PI/2;
const int BACKWARDS = PI;
const int LEFT = -PI/2;

const int R_FINGER_MIN = 165;
const int R_FINGER_MAX = 255;
const int L_FINGER_MIN = 90;
const int L_FINGER_MAX = 0;

// HTMC readings are in degrees. Yay!
const int TURN_TOWARDS_BOARD = 45;

const int DRIVE_FROM_CORNER_TIME = 2400;
const int DISTANCE_FROM_CENTER_RACK = 70;

void setVelocityVector(float magnitude, float theta)
{
  theta -= PI/4; // Make the arm be forwards
  int xPower = magnitude * cos(theta);
  int yPower = magnitude * sin(theta);
  motor[motorWest] = yPower;
  motor[motorEast] = yPower;
  motor[motorNorth] = xPower;
  motor[motorSouth] = xPower;
}

void rotateAtPower(int rotatePower)
{
  motor[motorWest] = rotatePower;
  motor[motorEast] = -rotatePower;
  motor[motorNorth] = rotatePower;
  motor[motorSouth] = -rotatePower;
}

void stopMotors()
{
  motor[motorWest] = 0;
  motor[motorEast] = 0;
  motor[motorNorth] = 0;
  motor[motorSouth] = 0;
}

task main()
{
  servo[servo2] = L_FINGER_MIN;
  servo[servo3] = R_FINGER_MIN;
  waitForStart();
  HTMCsetTarget(compass);
  PlaySoundFile("getiton.rso");
  int filteredUltrasonic = 9999;int baseSensor = 0;
  for (int i = 0; i < 10; i++)
    baseSensor += SensorValue[light];
  baseSensor /= 10;
  bool adjusted = false;
  long startTime = nPgmTime;
  while (filteredUltrasonic > 29)
  {
    if (nPgmTime-startTime > 7000)
    {
      setVelocityVector(-90,FORWARDS);
      rotateAtPower(70);
      wait1Msec(400);
      setVelocityVector(90,FORWARDS);
      startTime = nPgmTime;
    }
    if (!adjusted && ((float)(baseSensor - SensorValue[light])/baseSensor) > .10)
    {
      wait1Msec(300);
      rotateAtPower(50);
      wait1Msec(500);
      setVelocityVector(90,FORWARDS);
      wait1Msec(300);
      rotateAtPower(-50);
      wait1Msec(500);
      adjusted = true;
    }
    filteredUltrasonic = 0;
    for (int i = 0; i < 9; i++)
      filteredUltrasonic += SensorValue[ultrasonic];
    filteredUltrasonic /= 9;
    setVelocityVector(90,FORWARDS);
    int dTheta = HTMCreadRelativeHeading(compass);
    if (abs(dTheta) > 7)
    {
      while (abs(dTheta) > 2)
      {
        rotateAtPower(30*dTheta/abs(dTheta));
        dTheta = HTMCreadRelativeHeading(compass);
      }
    }
  }
  stopMotors();
  baseSensor = 0;
  for (int i = 0; i < 10; i++)
    baseSensor += SensorValue[light];
  baseSensor /= 10;
  //setVelocityVector(50,LEFT);
  motor[motorNorth] = 50;
  motor[motorEast] = 50;
  motor[motorSouth] = 50;
  motor[motorWest] = 50;
  float percentDiff = 0.0;
  while (percentDiff < .2)
  {
    percentDiff = ((float)(SensorValue[light] - baseSensor))/((float)baseSensor);
  }
  motor[motorNorth] = -50;
  motor[motorEast] = -50;
  motor[motorSouth] = -50;
  motor[motorWest] = -50;
  wait1Msec(240);
  stopMotors();

  /*int dTheta = HTMCreadRelativeHeading(compass);
  if (abs(dTheta) > 7)
  {
    while (abs(dTheta) > 2)
    {
      rotateAtPower(30*dTheta/abs(dTheta));
      dTheta = HTMCreadRelativeHeading(compass);
    }
  }*/

  filteredUltrasonic = 9999;
  long dTime = nPgmTime;
  while (filteredUltrasonic > 23 && nPgmTime-dTime < 2500)
  {
    writeDebugStreamLine("%d",SensorValue[ultrasonic]);
    filteredUltrasonic = 0;
    for (int i = 0; i < 9; i++)
      filteredUltrasonic += SensorValue[ultrasonic];
    filteredUltrasonic /= 9;
    setVelocityVector(70,FORWARDS);
  }
  dTime = nPgmTime;
  while ((filteredUltrasonic < 23 || filteredUltrasonic == 255)  && nPgmTime-dTime < 2500)
  {
    writeDebugStreamLine("%d",SensorValue[ultrasonic]);
    filteredUltrasonic = 0;
    for (int i = 0; i < 9; i++)
      filteredUltrasonic += SensorValue[ultrasonic];
    filteredUltrasonic /= 9;
    setVelocityVector(-50,FORWARDS);
  }
  stopMotors();

  servo[servo1] = 255;
  wait1Msec(4000);
  servo[servo1] = 127;

  PlaySound(soundBeepBeep);

  servo[servo2] = R_FINGER_MAX;
  servo[servo3] = L_FINGER_MAX;

  wait1Msec(2000);

  setVelocityVector(-90,FORWARDS);
  wait1Msec(700);
  stopMotors();

  return;
}
