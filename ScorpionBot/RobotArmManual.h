#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S3_C1_1,     shoulder,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     elbow,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_1,     motorNorth,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorEast,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorWest,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_2,     motorSouth,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_1,     wrist,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ROBOT_ARM_MANUAL

bool gripperAt90 = false;

const int SHOULDER_POWER = 40;
const int ELBOW_POWER = 60;
const int WRIST_POWER = 40;

const int JS_THRESHOLD = 15;

// If an encoder is this close to its target, it is good enough
// Marty /*and Michael*/, this one's for you
const int CLOSE_ENOUGH = 40;

struct
{
  int power;
  int positionToHold;
  int gravityModifierPower;
  int holdPositionPower;
  float degreesPerEncoder;
  float degreesAtZero;
  int closeEnough;
  int lastEncoderValue;
  int lastMilliseconds;
} Joint;

Joint jShoulder;
Joint jElbow;
Joint jWrist;

void moveToXY(float x, float y)
{
}

float degreesToEncoder(Joint joint, float degrees)
{
	return (degrees - joint.degreesAtZero) / joint.degreesPerEncoder;
}

float encoderToDegrees(Joint joint, float encoder)
{
	return encoder * joint.degreesPerEncoder + joint.degreesAtZero;
}

int coefficientForEncoder(int encoder, int target)
{
	if (abs(encoder-target) <= CLOSE_ENOUGH)
		return 0;
	if (encoder < target)
		return -1;
	return 1;
}

void init()
{
	nMotorEncoder[shoulder] = 0;
	nMotorEncoder[elbow] = 0;
	nMotorEncoder[wrist] = 0;

	jShoulder.power = 55;
	jShoulder.gravityModifierPower = 35;
	jShoulder.holdPositionPower = 6;
	jShoulder.degreesPerEncoder = -.0834;
	jShoulder.degreesAtZero = 296.131;
	jShoulder.closeEnough = 30;

	jElbow.power = -50;
	jElbow.gravityModifierPower = 0;
	jElbow.holdPositionPower = 6;
	jElbow.degreesPerEncoder = .084;
	jElbow.degreesAtZero = 8.65;
	jElbow.closeEnough = 30;

	jWrist.power = 27;
	jWrist.gravityModifierPower = 0;
	jWrist.holdPositionPower = 0;
	jWrist.degreesPerEncoder = .1665;
	jWrist.degreesAtZero = 21.643;
	jWrist.closeEnough = 30;
}

int powerForJoint(Joint joint, int encoderValue, int targetEncoder)
{
  float angle = degreesToRadians(encoderToDegrees(joint, encoderValue));
  float gravityMultipler = cos(angle);

  int motorDirectionCoefficient = ((encoderValue - targetEncoder) > 0 ?
				   1 : -1);

  int power = motorDirectionCoefficient * (joint.power);
	return power;
}

bool _wristBtnPressed = false;
bool elbowPowered = false;
bool shoulderPowered = false;

void setMotorPowers(TJoystick joystick)
{
	float angleC = encoderToDegrees(jElbow,nMotorEncoder[elbow]);
	float angleA = encoderToDegrees(jShoulder,nMotorEncoder[shoulder])*PI/180.0;
	float wristTargetAngle = angleC - PI + angleA + (gripperAt90 ? 0 : PI/4);

	int wristTarget = (int)degreesToEncoder(jWrist, wristTargetAngle * 180 / PI);

	//int wristPower = powerForJoint(jWrist, nMotorEncoder[wrist], wristTarget);
	//motor[wrist] = wristPower;

	int shoulderPower = 0;
	int elbowPower = 0;
	int wristPower = 0;

	if (abs(joystick.joy2_y1) > JS_THRESHOLD)
	{
		shoulderPower = -joystick.joy2_y1 / 128.0 * SHOULDER_POWER;
		shoulderPowered = true;
	}
	else if (!shoulderPowered)
	{
		shoulderPowered = false;
		jShoulder.positionToHold = nMotorEncoder[shoulder];
	}
	if (abs(joystick.joy2_y2) > JS_THRESHOLD)
	{
		elbowPower = joystick.joy2_y2 / 128.0 * ELBOW_POWER;
		elbowPowered = true;
	}
	else if (elbowPowered)
	{
		elbowPowered = false;
		jElbow.positionToHold = nMotorEncoder[elbow];
	}

	if (joy2Btn(8))
	{
		elbowPower*=2;
		shoulderPower*=2;
	}

	if (joy2Btn(5))
		wristPower = WRIST_POWER;
	else if (joy2Btn(7))
		wristPower = -WRIST_POWER;

	/*float angle = degreesToRadians(encoderToDegrees(jShoulder, nMotorEncoder[shoulder]));
  float gravityMultipler = cos(angle);
	if (shoulderPower == 0)
	{
		writeDebugStreamLine("HoldPosition: %d, pTH: %d", shoulderPower, jShoulder.positionToHold);
		if (abs(nMotorEncoder[shoulder]-jShoulder.positionToHold) > jShoulder.closeEnough)
		{
			shoulderPower = -jShoulder.holdPositionPower*coefficientForEncoder(nMotorEncoder[shoulder], jShoulder.positionToHold) * gravityMultipler;
		}
	}*/
	/*if (elbowPower == 0)
	{
		if (abs(nMotorEncoder[elbow]-jElbow.positionToHold) > jElbow.closeEnough)
		{
			elbowPower = -jElbow.holdPositionPower*coefficientForEncoder(nMotorEncoder[elbow], jElbow.positionToHold);
		}
	}*/

	motor[shoulder] = shoulderPower;
	motor[elbow] = elbowPower;
	motor[wrist] = wristPower;

	if (joy2Btn(6) && !_wristBtnPressed)
	{
		_wristBtnPressed = true;
		gripperAt90 = !gripperAt90;
	}
	else if (!joy2Btn(6))
	{
		_wristBtnPressed = false;
	}
}
