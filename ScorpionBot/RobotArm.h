#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S3_C1_1,     shoulder,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     elbow,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     wrist,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Values in inches. See drawings in engineer's notebook for details.
const float a = 15.25;
const float b = 15.25;
const float shoulderHeight = 14.5;

const float gripperHeight90 = 9;
const float gripperHeight45 = 6.364;

bool gripperAt90 = false;

float targetX = 17;
float targetY = 16;

int lastMotorEncoder = 0;
long lastMilliseconds = 0;

int lastMotorEncoderElbow = 0;
long lastMillisecondsElbow = 0;

const int ELBOW_POWER = 60;
const int SHOULDER_POWER = 39;
const int SHOULDER_POWER_MODIFIER = 35;
const int WRIST_POWER = 40;

const float H_TIER_1 = 18;
const float H_TIER_2 = 32;
const float H_TIER_3 = 42;

// If an encoder is this close to its target, it is good enough
// Marty /*and Michael*/, this one's for you
const int CLOSE_ENOUGH = 40;

struct
{
	int power;
	int gravityModifierPower;
	float degreesPerEncoder;
	float degreesAtZero;
	int closeEnough;
} Joint;

Joint jShoulder;
Joint jElbow;
Joint jWrist;

// These equations were determined using
// Experimental data and doing a linear
// Regression. They assume the most compact
// Starting position.
float degreesForShoulder(int encoder)
{
	return -.0834*encoder + 296.131;
}

float encoderForShoulder(float degrees)
{
	return (degrees - 296.131) / -.0834;
}

float degreesForElbow(int encoder)
{
	return -.0835*encoder + 5.219;
}

float encoderForElbow(float degrees)
{
	return (degrees - 5.219) / -.0835;
}

float encoderForWrist(float degrees)
{
	return (3.9267*degrees) - 82.7;
}

float degreesToEncoder(Joint joint, float degrees)
{
	return (degrees - joint.degreesAtZero) / joint.degreesPerEncoder;
}

float encoderToDegrees(Joint joint, float encoder)
{
	return encoder * joint.degreesPerEncoder + joint.degreesAtZero;
}

int coefficientForEncoder(int encoder, int target)
{
	if (abs(encoder-target) <= CLOSE_ENOUGH)
		return 0;
	if (encoder < target)
		return -1;
	return 1;
}

void init()
{
	nMotorEncoder[shoulder] = 0;
	nMotorEncoder[elbow] = 0;
	nMotorEncoder[wrist] = 0;

	jShoulder.power = 39;
	jShoulder.gravityModifierPower = 35;
	jShoulder.degreesPerEncoder = -.0834;
	jShoulder.degreesAtZero = 296.131;
	jShoulder.closeEnough = 40;

	jElbow.power = 60;
	jElbow.gravityModifierPower = 10;
	jElbow.degreesPerEncoder = -.0835;
	jElbow.degreesAtZero = 5.219;
	jElbow.closeEnough = 40;

	jWrist.power = 40;
	jWrist.gravityModifierPower = 0;
	jWrist.degreesPerEncoder = 1;
	jWrist.degreesAtZero = 1;
	jWrist.closeEnough = 30;
}

void setMotorPowersForXY()
{
	float gripperOffset = 0;
	if (gripperAt90)
		gripperOffset -= gripperHeight90;
	else
		gripperOffset -= gripperHeight45;

	float adjustedY = targetY + gripperOffset;

	float theta = PI/2 + atan((adjustedY-shoulderHeight)/(targetX));
	float c = sqrt(pow(adjustedY-shoulderHeight,2)+pow(targetX,2));
	float angleC = acos( (pow(c,2)-pow(b,2)-pow(a,2)) / (-2*a*b) );
	float angleA = asin( (a * sin(angleC) / c) );
	float wristTargetAngle = angleC - PI + angleA + theta + (gripperAt90 ? 0 : PI/4);

	int shoulderTarget = (int)encoderForShoulder((angleA + theta) * 180 / PI);
	int elbowTarget = (int)encoderForElbow(angleC * 180 / PI);
	int wristTarget = (int)encoderForWrist(wristTargetAngle * 180 / PI);

	nxtDisplayTextLine(0,"theta: %f",theta);
	nxtDisplayTextLine(1,"c: %f",c);
	nxtDisplayTextLine(2,"Lc: %f",angleC);
	nxtDisplayTextLine(3,"La: %f",angleA);
	nxtDisplayTextLine(5,"sT: %d", shoulderTarget);
	nxtDisplayTextLine(6,"eT: %d", elbowTarget);

	nxtDisplayTextLine(4,"shoulder: %f", degreesForShoulder(nMotorEncoder[shoulder]));

	if (c > a+b)
	{
		// Can't make a triangle from this!
		// Return instead of trying to kill the bot with a random arm movement
		if (!bSoundActive)
			PlaySound(soundBeepBeep);
		return;
	}

	float shoulderAngle = (degreesForShoulder(nMotorEncoder[shoulder]) - 90)*PI/180.0;
	float multiplier = 0;
	multiplier = cos(shoulderAngle);

	int powerBoost = 0;

	if (abs(nMotorEncoder[shoulder] - lastMotorEncoder) < CLOSE_ENOUGH && abs(nMotorEncoder[shoulder] - shoulderTarget) > CLOSE_ENOUGH)
	{
		if (nPgmTime - lastMilliseconds > 250)
		{
			powerBoost = 15;
		}
	}
	else if (abs(nMotorEncoder[shoulder] - lastMotorEncoder) > CLOSE_ENOUGH/2 && nPgmTime-lastMilliseconds > 500)
	{
		lastMotorEncoder = nMotorEncoder[shoulder];
		lastMilliseconds = nPgmTime;
	}

	int elbowPowerBoost = 0;

	if (abs(nMotorEncoder[elbow] - lastMotorEncoderElbow) < CLOSE_ENOUGH && abs(nMotorEncoder[elbow] - elbowTarget) > CLOSE_ENOUGH)
	{
		if (nPgmTime - lastMillisecondsElbow > 250)
		{
			elbowPowerBoost = 15;
		}
	}
	else if (abs(nMotorEncoder[elbow] - lastMotorEncoderElbow) > CLOSE_ENOUGH/2 && nPgmTime-lastMillisecondsElbow > 500)
	{
		lastMotorEncoderElbow = nMotorEncoder[elbow];
		lastMillisecondsElbow = nPgmTime;
	}

	float shoulderPower = (SHOULDER_POWER_MODIFIER*multiplier*((nMotorEncoder[shoulder]-shoulderTarget)>0?1:-1)
								   + SHOULDER_POWER + powerBoost)*coefficientForEncoder(nMotorEncoder[shoulder], shoulderTarget);

	writeDebugStreamLine("%f",shoulderPower);

	motor[elbow] = -ELBOW_POWER*coefficientForEncoder(nMotorEncoder[elbow], elbowTarget);
	motor[shoulder] = shoulderPower;
	motor[wrist] = -WRIST_POWER*coefficientForEncoder(nMotorEncoder[wrist], wristTarget);
}
