#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S2_C1_1,     wrist,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     motorNorth,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorEast,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorWest,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_2,     motorSouth,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_1,     elbow,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     shoulder,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "RobotArmPID.h"
#include "rdpartyrobotcdr-3.1/drivers/hitechnic-sensormux.h"
#include "rdpartyrobotcdr-3.1/drivers/hitechnic-irseeker-v2.h"
#include "rdpartyrobotcdr-3.1/drivers/lego-ultrasound.h"
#include "rdpartyrobotcdr-3.1/drivers/lego-light.h"
#include "rdpartyrobotcdr-3.1/drivers/hitechnic-compass.h"

const tMUXSensor ULTRASONIC = msensor_S3_4;
const tMUXSensor LIGHT = msensor_S3_2;
const tMUXSensor COMPASS = msensor_S3_3;

const int THRESHOLD = 20;
const float ARM_ADJUST_SPEED = .16;

bool isOnPID = true;
bool btn10Pressed = false;

float dTheta = PI/4;  // Set forwards on the joystick to the direction of the arm

void operateArmPID();
void operateArmManual();
void rotateAtPower(int rotatePower);

const float e = 2.718281828;

int powerForJoystickVal(float value)
{
	int sign = 1;
	if (value < 0)
	{
		value *= -1;
		sign = -1;
	}
	float result = sign*10*pow(e, 0.01799 * value);
	return result;
}

task main()
{
	waitForStart();
	init();

	servo[servo6] = 225;

	while (true)
	{
		getJoystickSettings(joystick);

		int xJoy = 0;
    int yJoy = 0;
    int rotatePower = 0;

    if (abs(joystick.joy1_x1) > THRESHOLD)
      xJoy = powerForJoystickVal(joystick.joy1_x1);
    if (abs(joystick.joy1_y1) > THRESHOLD)
      yJoy = powerForJoystickVal(joystick.joy1_y1);
    float theta = 0;
    if (xJoy == 0)
      theta = (yJoy > 0 ? PI/2 : 3*PI/2);
    else
      theta = atan((float)yJoy/xJoy);
    if (xJoy < 0)
      theta += PI;

    float magnitude = sqrt(pow(xJoy,2) + pow(yJoy,2));
    theta += dTheta;

    int xPower = magnitude * cos(theta);
    int yPower = magnitude * sin(theta);

    if (abs(joystick.joy1_x2) > THRESHOLD)
      rotatePower = powerForJoystickVal(joystick.joy1_x2);

    if (rotatePower == 0)
    {
      motor[motorWest] = yPower;
      motor[motorEast] = yPower;
      motor[motorNorth] = -xPower;
      motor[motorSouth] = -xPower;
    }
    else
    {
      rotateAtPower(rotatePower);
    }

    if (joy2Btn(10) && !btn10Pressed)
    {
    	btn10Pressed = true;
    	isOnPID = !isOnPID;
    }
    else if (!joy2Btn(10))
    	btn10Pressed = false;

    if (joy2Btn(9))
    {
    	targetX = startX;
    	targetY = startY;
    }

    shouldPowerWrist = true;
    if (isOnPID)
    	operateArmPID();
   	else
   		operateArmManual();
	}
}

void operateArmPID()
{
	servo[servo1] = 128;
	setMotorPowersForXY();
		if (joy2Btn(1))
			moveToXY(targetX + ARM_ADJUST_SPEED, targetY);
		else if (joy2Btn(3))
			moveToXY(targetX - ARM_ADJUST_SPEED, targetY);

		if (joy2Btn(4))
			moveToXY(targetX, targetY + ARM_ADJUST_SPEED);
		else if (joy2Btn(2))
			moveToXY(targetX, targetY - ARM_ADJUST_SPEED);

		if (joystick.joy2_TopHat == 0)
		{
			moveToXY(X_TIER_3, H_TIER_3);
		}
		else if (joystick.joy2_TopHat == 2)
		{
			moveToXY(X_TIER_2, H_TIER_2);
		}
		else if (joystick.joy2_TopHat == 6)
		{
			moveToXY(X_TIER_2_UPPER, H_TIER_2_UPPER);
		}
		else if (joystick.joy2_TopHat == 4)
		{
			moveToXY(X_TIER_1, H_TIER_1);
		}
		if (joy2Btn(5))
			moveToXY(X_DISPENSER, H_DISPENSER);

  if (abs(joystick.joy2_y1) > 15)
  	wristNudge = joystick.joy2_y1/5;
 	else
 		wristNudge = 0;


  if (joy2Btn(11))
  	moveToXY(startX,targetY);
 	if (joy2Btn(12))
 		moveToXY(targetX,startY);
}

void operateArmManual()
{
	servo[servo1] = 0;
	if (joy2Btn(6))
		motor[shoulder] = 90;
	else if (joy2Btn(8))
		motor[shoulder] = -90;
	else
		motor[shoulder] = 0;

	if (abs(joystick.joy2_y1) > 10)
		motor[wrist] = 60 * -joystick.joy2_y1 / 128;
	else
		motor[wrist] = 0;

	if (abs(joystick.joy2_y2) > 10)
		motor[elbow] = 60 * joystick.joy2_y2 / 128;
	else
		motor[elbow] = 0;
}

void rotateAtPower(int rotatePower)
{
  motor[motorWest] = -rotatePower;
  motor[motorEast] = rotatePower;
  motor[motorNorth] = rotatePower;
  motor[motorSouth] = -rotatePower;
}
