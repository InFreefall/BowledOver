#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S3_C1_1,     shoulder,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     elbow,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     wrist,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Values in inches. See drawings in engineer's notebook for details.
const float a = 15.25;
const float b = 15.25;
const float shoulderHeight = 14.5;

const float gripperHeight90 = 9;
const float gripperHeight45 = 6.364;

bool gripperAt90 = false;

float targetX = 17;
float targetY = 16;

const float H_TIER_1 = 18;
const float H_TIER_2 = 32;
const float H_TIER_3 = 46;

// If an encoder is this close to its target, it is good enough
// Marty /*and Michael*/, this one's for you
const int CLOSE_ENOUGH = 40;

struct
{
  int power;
  int gravityModifierPower;
  int holdPositionPower;
  float degreesPerEncoder;
  float degreesAtZero;
  int closeEnough;
  int lastEncoderValue;
  int lastMilliseconds;
} Joint;

Joint jShoulder;
Joint jElbow;
Joint jWrist;

float degreesToEncoder(Joint joint, float degrees)
{
	return (degrees - joint.degreesAtZero) / joint.degreesPerEncoder;
}

float encoderToDegrees(Joint joint, float encoder)
{
	return encoder * joint.degreesPerEncoder + joint.degreesAtZero;
}

int coefficientForEncoder(int encoder, int target)
{
	if (abs(encoder-target) <= CLOSE_ENOUGH)
		return 0;
	if (encoder < target)
		return -1;
	return 1;
}

void init()
{
	nMotorEncoder[shoulder] = 0;
	nMotorEncoder[elbow] = 0;
	nMotorEncoder[wrist] = 0;

	jShoulder.power = 45;
	jShoulder.gravityModifierPower = 30;
	jShoulder.holdPositionPower = 6;
	jShoulder.degreesPerEncoder = -.0834;
	jShoulder.degreesAtZero = 296.131;
	jShoulder.closeEnough = 40;

	jElbow.power = -40;
	jElbow.gravityModifierPower = 0;
	jElbow.holdPositionPower = 0;
	jElbow.degreesPerEncoder = -.0835;
	jElbow.degreesAtZero = 5.219;
	jElbow.closeEnough = 40;

	jWrist.power = -40;
	jWrist.gravityModifierPower = 0;
	jWrist.holdPositionPower = 0;
	jWrist.degreesPerEncoder = .1665;
	jWrist.degreesAtZero = 21.643;
	jWrist.closeEnough = 30;
}

int powerForJoint(Joint joint, int encoderValue, int targetEncoder)
{
  float angle = degreesToRadians(encoderToDegrees(joint, encoderValue));
  float gravityMultipler = cos(angle);

  int powerBoost;

  if (abs(encoderValue - joint.lastEncoderValue) < joint.closeEnough &&
      abs(encoderValue - targetEncoder) > joint.closeEnough)
    {
      if (nPgmTime - joint.lastMilliseconds > 250)
	powerBoost = 15;
    }
  else if (abs(encoderValue - joint.lastEncoderValue) > joint.closeEnough/2 &&
	   nPgmTime - joint.lastMilliseconds > 500)
    {
      joint.lastEncoderValue = encoderValue;
      joint.lastMilliseconds = nPgmTime;
    }

  int motorDirectionCoefficient = ((nMotorEncoder[shoulder] - targetEncoder) > 0 ?
				   1 : -1);

  float gravityPower = joint.gravityModifierPower *
    gravityMultipler *
    motorDirectionCoefficient;

  if (abs(encoderValue - targetEncoder) < joint.closeEnough)
    return joint.holdPositionPower * gravityMultipler;
  else
    return motorDirectionCoefficient * (gravityPower + powerBoost + joint.power);
}

void setMotorPowersForXY()
{
	float gripperOffset = 0;
	if (gripperAt90)
		gripperOffset -= gripperHeight90;
	else
		gripperOffset -= gripperHeight45;

	float adjustedY = targetY + gripperOffset;

	float theta = PI/2 + atan((adjustedY-shoulderHeight)/(targetX));
	float c = sqrt(pow(adjustedY-shoulderHeight,2)+pow(targetX,2));
	float angleC = acos( (pow(c,2)-pow(b,2)-pow(a,2)) / (-2*a*b) );
	float angleA = asin( (a * sin(angleC) / c) );
	float wristTargetAngle = angleC - PI + angleA + theta + (gripperAt90 ? 0 : PI/4);

	int shoulderTarget = (int)degreesToEncoder(jShoulder, (angleA + theta) * 180 / PI);
	int elbowTarget = (int)degreesToEncoder(jElbow, angleC * 180 / PI);
	int wristTarget = (int)degreesToEncoder(jWrist, wristTargetAngle * 180 / PI);

	nxtDisplayTextLine(0,"theta: %f",theta);
	nxtDisplayTextLine(1,"c: %f",c);
	nxtDisplayTextLine(2,"Lc: %f",angleC);
	nxtDisplayTextLine(3,"La: %f",angleA);
	nxtDisplayTextLine(5,"sT: %d", shoulderTarget);
	nxtDisplayTextLine(6,"eT: %d", elbowTarget);

	nxtDisplayTextLine(4,"shoulder: %f", encoderToDegrees(jShoulder,nMotorEncoder[shoulder]));

	if (c > a+b)
	{
		// Can't make a triangle from this!
		// Return instead of trying to kill the bot with a random arm movement
		if (!bSoundActive)
			PlaySound(soundBeepBeep);
		return;
	}

	int sPower = powerForJoint(jShoulder, nMotorEncoder[shoulder], shoulderTarget);
	writeDebugStreamLine("sh: %d",sPower);

	motor[elbow] = powerForJoint(jElbow, nMotorEncoder[elbow], elbowTarget);
	motor[shoulder] = sPower;
	motor[wrist] = powerForJoint(jWrist, nMotorEncoder[wrist], wristTarget);
}
